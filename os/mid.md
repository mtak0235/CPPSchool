 

# ê¸°ë³¸ì ì¸ OSê°œë…ê³¼ í˜•íƒœ

## OSê°€ ë­ì•¼?

ì»´í“¨í„° ì‹œìŠ¤í…œì—ì„œ,
í•˜ë“œì›¨ì–´ ìì›ì„ ë…ì  ê´€ë¦¬í•˜ê³ , 
í•˜ë“œì›¨ì–´ë¥¼ ì¶”ìƒí™” â†’ í”„ë¡œê·¸ë¨ì—ê²Œ ì¸í„°í˜ì´ìŠ¤ë¡œ ì œê³µí•˜ëŠ” 
ì‹œìŠ¤í…œ ì†Œí”„íŠ¸ì›¨ì–´.

## ì»´í“¨í„°ë¥¼ ì˜ ì“°ê¸° ìœ„í•œ OSì˜ ì—­í•  4ê°€ì§€?

* ìì› ê´€ë¦¬
* ìì› ë³´í˜¸
* hwë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ ì œê³µ
* ì‚¬ìš©ìë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ ì œê³µ

## OS ë‹¨ì ì€ ì—†ëŠ”ê±°ì•¼?

ì„±ëŠ¥ ëŠë¦¬ê³ , ë¬´ì§€ì„±ìœ¼ë¡œ ì—°ê²°ë‹¹í•˜ëŠ”ê²ƒë³´ë‹¨ ì•„ì˜ˆ ë§‰ì•„ë†“ëŠ”ê²Œ ì•ˆì „í• ì§€ë„

## í•˜ë‚˜ì˜ CPUë¡œ ì–´ë–»ê²Œ ì—¬ëŸ¬ swë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆì–´?

ê·¸ëŸ° ê¸°ìˆ ì„ multi-taskingì´ë¼ ë¶€ë¥´ëŠ”ë°,  CPUê°€ ì§§ì€ ì‹œê°„ ë™ì•ˆ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ë²ˆê°ˆì•„ ê°€ë©° ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ ìš´ì˜ì²´ì œê°€ ê´€ë¦¬í•´ì¤˜.

## í”„ë¡œì„¸ìŠ¤ê°€ ì–¸ì œ ì‘ë™ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ì–´ë–»ê²Œ ê²°ì •í•´?

ê·¸ê±¸ ê²°ì •í•˜ëŠ”ê²Œ  ìŠ¤ì¼€ì¥´ë§ ì•Œê³ ë¦¬ì¦˜ì´ì•¼.

Round Robin, FCFS, SJF ë“±ì´ ìˆì§€.

## í”„ë¡œì„¸ìŠ¤ë¥¼ ë°”ê¾¸ë ¤ë©´ ë­˜ ì¤€ë¹„í•´ì•¼í•˜ì§€?

ì‹¤í–‰í•˜ë˜ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨í•˜ê³  (=í˜„ì¬ ì‹¤í–‰í•˜ë˜ í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœë¥¼ ì¼ë‹¨ ì €ì¥í•˜ê³ )

ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ë¥¼ ë©”ëª¨ë¦¬ì— ì˜¬ë ¤ì•¼ê² ì§€.  (= ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœë¥¼ ë³µì›)

â†’ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì„ í•´ì•¼í•´

## í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœì—ëŠ” ì–´ë–¤ê²Œ ìˆì–´?



## ì¤‘ë‹¨ëœ í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœëŠ” ì–´ë””ì— ì €ì¥ë˜ëŠ”ê±°ì•¼?

í•˜ë“œë””ìŠ¤í¬ì˜ ì¼ë¶€ë¥¼ ë©”ëª¨ë¦¬ë¡œ ì‚¬ìš©í•´ì„œ (= ê°€ìƒ ë©”ëª¨ë¦¬)

ì¤‘ë‹¨ëœ í”„ë¡œì„¸ìŠ¤ë¥¼ ê±°ê¸°ì— ì €ì¥í•´ ë†¨ë‹¤ê°€

í•„ìš”í•˜ë©´ ë©”ëª¨ë¦¬ë¡œ ë¶ˆëŸ¬ì™€.

## í”„ë¡œì„¸ìŠ¤ê°€ ë©”ëª¨ë¦¬ì— ê³„ì† ë“¤ë½ë‚ ë½ í•´ì•¼í•˜ëŠ”ë° ì–´ë–»ê²Œ í•´?



## CPUë‘ ë©”ëª¨ë¦¬ëŠ” ì–´ë–»ê²Œ ì—°ê²°í•˜ì§€?

ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” í†µë¡œì¸, ë²„ìŠ¤ë¥¼ í†µí•´ ì—°ê²°ë˜.

## ë‚´ë ¤ê°„ í”„ë¡œì„¸ìŠ¤ëŠ” ì–´ë””ì— ë‘ì§€?

ê·¸ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•˜ê³  í• ë‹¹ë˜ì–´ ìˆë˜ ìì›ì„ ë°˜ë‚©í•´ì•¼ë¼.



## OSëŠ” ì–´ë–»ê²Œ ìƒê²¼ì–´?

* í”„ë¡œì„¸ìŠ¤, ë©”ëª¨ë¦¬, ì €ì¥ì¥ì¹˜ ê´€ë¦¬ ê¸°ëŠ¥ì„ ëª¨ì•„ë‘” **Kernel**
* kernelì— ëª…ë ¹ì„ ì „ë‹¬í•˜ê³  ì‹¤í–‰ ê²°ê³¼ë¥¼ ì•Œë ¤ì£¼ëŠ” **interface**
* hardwareì„ ì¶”ìƒí™”ì‹œì¼œë†“ì€ **device driver**

## kernelì´ ìì‹ ì˜ ê¸°ëŠ¥ì„ í•¨ìˆ˜ í˜•íƒœë¡œ ì œê³µí•´ì£¼ëŠ” ê²ƒì„ interfaceë¼ê³  í•œë‹¤.

ì—¿. system callì´ë¼ê³  í•œë‹¤. ì¸í„°í˜ì´ìŠ¤ ì¤‘ í•˜ë‚˜ê°€  system callì´ë‹¤.

## í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë˜ëŠ” ë‘ê°€ì§€ ëª¨ë“œê°€ ë­ì•¼?

usermode, kernel mode

## user modeì—ì„œëŠ” ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ë©°, ì‹œìŠ¤í…œ ìì›ì— ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.

ì—¿. system callë¡œ ì‹œìŠ¤í…œ ìì›ì— ê°„ì ‘ì ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤. ê·¸ ë•Œ kernel modeë¡œ ê´€ë ¨ëœ ì»¤ë„ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë“¤ì´ ëŒì•„ê°„ë‹¤.

## OSëŠ” ì–´ë–¤ ê³¼ì •ìœ¼ë¡œ ì§„í™”í–ˆì–´?

1. ê³ ì • í”„ë¡œê·¸ë˜ë° ë°©ì‹
   * ì‘ì—…ì„ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤ í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì…ë ¥í•˜ì—¬ ì‹¤í–‰í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
2. ë‚´ì¥ í”„ë¡œê·¸ë˜ë° ë°©ì‹
   * ì‘ì—…ì„ ì²˜ë¦¬í•˜ëŠ” ë° í•„ìš”í•œ í”„ë¡œê·¸ë¨ì´ í•˜ë“œì›¨ì–´(í€ì¹˜ ì¹´ë“œ)ì— ë¯¸ë¦¬ ì í˜€ ìˆìœ¼ë¯€ë¡œ,
     ì‘ì—…ì„ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤ í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì…ë ¥í•˜ì—¬ ì‹¤í–‰í•  í•„ìš”ê°€ ì—†ì´
     ì‹¤í–‰í•  ë¡œì§ì„  ì¹´ë“œ ë¦¬ë”ê¸°ë¡œ ì½ì–´ ë©”ëª¨ë¦¬ì— ë‹´ê³ ,  (= í•˜ë“œì›¨ì–´ì™€ ì†Œí”„íŠ¸ì›¨ì–´ì˜ ë¶„ë¦¬)
     CPUê°€ ë¡œì§ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹
   * ë¯¸ë¦¬ ì •ì˜ëœ ì¼ë ¨ì˜ ì‘ì—…ì„ ì¼ê´„ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë‹ˆê¹Œ â†’ batch processing ì‹œìŠ¤í…œì˜ íƒ„ìƒì´ë¡œêµ°.
     * ë¯¸ë¦¬ ì •ì˜ëœê²ƒë§Œ ì²˜ë¦¬í•˜ë‹ˆê¹Œ **ì¤‘ê°„ì—** ì…ë ¥ê°’ìœ¼ë¡œ ì‹¤í–‰ íë¦„ì„ ëª»ë°”ê¿ˆ (I/OëŠ” í•  ìˆ˜ ìˆìŒ)
       â†’ ì‘ì—…ì„ êµì²´í•´ì„œë¼ë„ ëŒë ¤ë³´ë ¤ê³  í•˜ë‹ˆ, í€ì¹˜ ì¹´ë“œ ì½ëŠ”ë° í•œ ì„¸ì›” ğŸ¥²
3. ëŒ€í™”í˜• ì‹œìŠ¤í…œ
   * ì…ë ¥ ê°’ì— ë”°ë¼ ì‘ì—… íë¦„ì„ ë³€ê²½í•  ìˆ˜ ìˆê²Œ ëœ ì‹œìŠ¤í…œ!
     * ê·¸ë ‡ë‹¤ë©´ í‚¤ë³´ë“œë¡œ ì…ë ¥í•˜ê³  ëª¨ë‹ˆí„°ë¡œ ì¶œë ¥í• ë˜! â†’ê·¼ë° ìŠ¤ë¬´ìŠ¤í•˜ì§€ ì•Šë„¤..? ì¥ì¹˜ í•˜ë‚˜ì—ì„œ ì‘ì—… ì—¬ëŸ¬ê°œ ëŒë¦´ ìˆœ ì—†ì„ê¹Œ?
4. ë‹¤ì¤‘ í”„ë¡œê·¸ë˜ë°
   * ì‘ì—…ë‹¹ CPU ì‚¬ìš© ì‹œê°„ì„ ë¶„í• í•´ì„œ ì—¬ëŸ¬ ì‘ì—…ì´ ì‹¤í–‰ì´ ë™ì‹œì— ë˜ëŠ”ê²ƒ ì²˜ëŸ¼ ë³´ì´ê²Œ í•¨.
     * I/O ì¤‘ì¸ ì‘ì—…ì€ CPU ì•ˆì°¨ì§€ í•˜ë‹ˆê¹Œ ë‹¤ë¥¸ ì‘ì—… í•˜ë©´ ë˜ê² ë‹¤! ìŠ¤ë¬´ìŠ¤í•˜ê²Œ ë³´ì´ê² êµ° ã…ã…
5. ë„¤íŠ¸ì›Œí¬ ê¸°ë°˜ ì‹œìŠ¤í…œ
   * ìì›ì´ ì¥ì¹˜ ë°–ê¹Œì§€ í™•ì¥

## ë°ë“œë¼ì¸ ì‹œê°„ ë‚´ì— ì²˜ë¦¬ë¥¼ ë³´ì¥í•˜ëŠ” OS?

ì‹¤ì‹œê°„ ìš´ì˜ì²´ì œ

## ì»´í“¨í„° ìœ„ì—ì„œ í•˜ë“œì›¨ì–´ì¸ ì»´í“¨í„°ë¥¼ ì†Œí”„íŠ¸ì›¨ì–´ë¡œ ë§Œë“¤ì–´ ëŒë¦¬ëŠ” ì‹œìŠ¤í…œì€?

ê°€ìƒí™” ì‹œìŠ¤í…œ (virtualization)

## os apië¥¼ ì†Œí”„íŠ¸ì›¨ì–´ë¡œ ì‹œë®¬ë ˆì´ì…˜ í•˜ëŠ” ê²ƒì´ ê°€ìƒë¨¸ì‹ ì´ë‹¤.

ì—¿. ê³¼ì •ê¹Œì§€ ì¬í˜„í•œ (=ì—ë®¬ë ˆì´ì…˜ í•œ) ê²ƒì´ë‹¤. 

## virtualizationì´ ê°€ìƒë¨¸ì‹ ë³´ë‹¤ emulation ë²”ìœ„ê°€ ë” ë„“ë‹¤.

ë§ìŒ. virtualizationì€ ì»´í“¨í„°ë¥¼ ì¬í˜„í•œ ê²ƒì´ê³ , ê°€ìƒë¨¸ì‹ (JVM...)ì€ syscallë§Œ ì¬í˜„í•œ ê²ƒì´ë‹¤. 

## ê°€ìƒ ë¨¸ì‹ ì€ ìš´ì˜ì²´ì œì™€ ì‘ìš© í”„ë¡œê·¸ë¨ ì‚¬ì´ì—ì„œ ëŒì•„ê°„ë‹¤.

ë§ìŒ.

## ì„œë²„ë¥¼ ê±°ì¹˜ì§€ ì•Šê³  ì‚¬ìš©ìì™€ ì‚¬ìš©ìë¥¼ ì§ì ‘ ì—°ê²°í•˜ëŠ” ì‹œìŠ¤í…œì€?

P2P(Peer to Peer) system

## OSëŠ” ì–´ë–¤ ìì›ì„ ê´€ë¦¬í•´?

* í”„ë¡œì„¸ìŠ¤ - ì´ ì‘ì—… ì–¸ì œ ì²˜ë¦¬í•˜ì§€?
* ë©”ëª¨ë¦¬ - ì´ ì¢ì€ ë©”ëª¨ë¦¬ì— ì–´ë–¤ ì‘ì—…ì„ ì˜¬ë ¤ì•¼í• ê¹Œ?
* íŒŒì¼ ì‹œìŠ¤í…œ
* ì¥ì¹˜
* ë³´ì•ˆ
* ë„¤íŠ¸ì›Œí¬

## í•˜ë“œì›¨ì–´ì˜ I/O ì‹ í˜¸ ê·œì¹™ì€ ë„¤íŠ¸ì›Œí¬ device driveê°€ ì •í•œë‹¤.

ë§ìŒ. "ê·¸ ì‹ í˜¸ ì´ í•¨ìˆ˜ë¡œ ã„±ã„±"



## ì»¤ë„ì´ í”„ë¡œì„¸ìŠ¤ê°„ í†µì‹  ê¸°ëŠ¥ë§Œ í•˜ê³ , ë‚˜ë¨¸ì§€ ê¸°ëŠ¥ì€ user modeë¡œ ì˜¬ë ¤ë†“ì€ ë†”ì„œ ì†ë„ê°€ ë’¤ì§€ê²Œ ëŠë¦° ê²ƒì„ ê³„ì¸µí˜• ì»¤ë„ì´ë¼ê³  í•œë‹¤.

ì—¿. ë§ˆì´í¬ë¡œ ì»¤ë„ì´ë¼ê³  í•œë‹¤. 

## ë§ˆì´í¬ë¡œ ì»¤ë„ì€ í”„ë¡œì„¸ìŠ¤ê°€ ì£½ìœ¼ë©´ ë‹¤ìš´ëœë‹¤.

ì—¿. ê·¸ë˜ì„œ ë§ˆìŒë†“ê³  ë””ë²„ê¹…í•  ìˆ˜ ìˆìŒ.

 # Computer architecture: ê°„ë‹¨í•œ ì»´í“¨í„°ì˜ êµ¬ì¡°ì™€ ì‘ë™ë°©ì‹, ë³‘ë ¬ì²˜ë¦¬

## ì»´í“¨í„°ì˜ êµ¬ì¡°ëŠ” ì–´ë–»ê²Œ ìƒê²¼ì–´?

* CPU - ëª…ë ¹ì–´ë¥¼ í•´ì„ & ì‹¤í–‰í•˜ëŠ” ì¥ì¹˜
* ë©”ëª¨ë¦¬ - ëª…ë ¹ì–´ì™€ í•„ìš”í•œ ë°ì´í„° ì €ì¥í•˜ëŠ” ê³³.
* ë²„ìŠ¤ - ë°ì´í„° í†µë¡œ

## ë²„ìŠ¤ëŠ” í•œë²ˆì— ì—¬ëŸ¬ ë©”ëª¨ë¦¬ ì£¼ì†Œì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.

ì—¿. í•˜ë‚˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë°–ì— ì ‘ê·¼ ëª»í•œë‹¤.

## í° ë…¸ì´ë§Œ êµ¬ì¡°ì˜ ë‹¨ì ì´ ë­ì•¼?

CPUê°€ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰ì‹œí‚¤ë ¤ë©´ ë¬´ì¡°ê±´ ë©”ì¸ ë©”ëª¨ë¦¬ì— ì ì¬ë˜ì–´ ìˆì–´ì•¼ í•˜ëŠ” íƒ“ì—,
ë©”ëª¨ë¦¬ì— ê°‘ìê¸° ë§ì€ ì…ì¶œë ¥ì´ ë°œìƒí•˜ë©´, (= ì´í›„ ìš”ì²­ë“¤ì€ í•˜ë‚˜ë¿ì¸ ë°ì´í„°ë²„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì„ ë•Œ ê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•´ì„œ, CPUì— ë¹„í•´ ë©”ëª¨ë¦¬ì˜ ì‘ì—… ì†ë„ê°€ ëŠë ¤ì§.)
ë³‘ëª©í˜„ìƒì´ ìƒê¸´ë‹¤.

## ì¥ì¹˜ë“¤ì˜ ì‘ë™ì„ ë™ê¸°í™”í•´ì£¼ëŠ” íƒ€ì´ë°ì„ ë­ë¼ê³  í•´?

í´ëŸ­

## rwë¥¼ ì‹£ëŠ” ë²„ìŠ¤

ì œì–´ ë²„ìŠ¤

## ë²„ìŠ¤ì˜ í¬ê¸°ê°€ 2ë°° ëŠ˜ì–´ë‚˜ë©´, wordë„ 2ë°° ëŠ˜ì–´ë‚œë‹¤.

ì—¿. **í•œë²ˆì— ì „ì†¡í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ì˜ í¬ê¸°**ê°€ 2ë°°ê°€ ëœë‹¤ê³  í•´ì„œ CPUê°€ í•œë²ˆì— ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ì˜ í¬ê¸°ê°€ ëŠ˜ì–´ë‚˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.

## ì•ìœ¼ë¡œ ì‚¬ìš©í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ëŠ” ë°ì´í„°ë¥¼ ë¯¸ë¦¬ ê°€ì ¸ì™€ ì €ì¥í•´ë‘ëŠ” ì¥ì†Œë¥¼ ë²„í¼ë¼ê³  í•œë‹¤.

ì—¿. ìºì‹œë‹¤.  ì†ë„ ì°¨ì´ê°€ ìˆëŠ” ì¥ì¹˜ ì‚¬ì´ì—ì„œ ì™„í™”í•˜ëŠ”ê²Œ ë²„í¼ë‹¤. 

ì˜ íŒ”ë¦¬ëŠ”ê±´ ê·¼ì²˜ì— ë‘”ë‹¤ â†’ ìºì‹œ

ë°”ì˜ë‹ˆê¹Œ í•œ ë‹¤ë¼ì´ì— â†’ ë²„í¼

## ë©”ëª¨ë¦¬ì˜ ê³„ì¸µêµ¬ì¡°ëŠ” ì–´ë–»ê²Œ ìƒê²¼ì–´?

cpuì™€ ë©”ëª¨ë¦¬ ì‚¬ì´ì— ë¼ì¸ ìºì‹œì— CPUê°€ ìì£¼ ì‚¬ìš©í•˜ëŠ” ë°ì´í„°ë‚˜ ëª…ë ¹ì–´ê°€ ì €ì¥ëœë‹¤.

## CPUê°€ ìš”ì²­í•œ ë°ì´í„°ê°€ ìºì‹œì— ì—†ìœ¼ë©´(ìºì‹œ ë¯¸ìŠ¤) CPUëŠ” ë©”ëª¨ë¦¬ì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ë°”ë¡œ ì“´ë‹¤.

ì—¿.ìºì‹œì— ì €ì¥í•˜ê³  ë‹¤ì‹œ  ìºì‹œ íˆíŠ¸.

## CPUëŠ” ì–´ë–»ê²Œ êµ¬ì„±ë˜ì–´ ìˆì–´?

* Arithmetic logic unit
* control unit
* register

## CPU ë‚´ì˜ ì‘ì—…ì€ ëª¨ë‘ê°€ registerë¥¼ ê±°ì¹˜ëŠ”ê±´ ì•„ë‹ˆë‹¤.

ì—¿.ë‹¤ ê±°ì¹¨.

## cpuëŠ” ëª…ë ¹ì–´ë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•´?

1. Fetch(ì¸ì¶œ): CPUëŠ” ë©”ëª¨ë¦¬ì—ì„œ ë‹¤ìŒ ì‹¤í–‰í•  ëª…ë ¹ì–´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. ì´ ëª…ë ¹ì–´ëŠ” CPU ë‚´ë¶€ì˜ ëª…ë ¹ì–´ ë ˆì§€ìŠ¤í„°(Instruction Register)ì— ì €ì¥ë©ë‹ˆë‹¤.
2. Decode(í•´ì„): CPUëŠ” ëª…ë ¹ì–´ ë ˆì§€ìŠ¤í„°ì— ì €ì¥ëœ ëª…ë ¹ì–´ë¥¼ í•´ì„í•©ë‹ˆë‹¤. ì´ë•Œ ëª…ë ¹ì–´ì˜ ì˜¤í¼ë ˆì´ì…˜(Operation)ê³¼  ì˜¤í¼ëœë“œ(Operand-ì—°ì‚°ì— ì‚¬ìš©ë  ë°ì´í„°ì˜ ìœ„ì¹˜)ë¥¼ êµ¬ë¶„í•˜ê³ , í•„ìš”í•œ ë ˆì§€ìŠ¤í„°ë‚˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ ë“±ì„ ê²°ì •í•©ë‹ˆë‹¤.
3. Execute(ì‹¤í–‰): CPUëŠ” ëª…ë ¹ì–´ì— ë”°ë¼ ì ì ˆí•œ ê³„ì‚°ì´ë‚˜ ì—°ì‚°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ë•Œ í•„ìš”í•œ ë°ì´í„°ëŠ” ë ˆì§€ìŠ¤í„°ë‚˜ ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê²Œ ë©ë‹ˆë‹¤.
4. Store(ì €ì¥): CPUëŠ” ëª…ë ¹ì–´ê°€ ì‹¤í–‰ëœ ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ë‚˜ ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•©ë‹ˆë‹¤.

## í”„ë¡œê·¸ë¨ì„ ì„œë¡œ ë¶„ë¦¬ëœ ë…¼ë¦¬ì ì¸ ë¸”ë¡ìœ¼ë¡œ ë‚˜ëˆ ì„œ, ì‘ì—…ì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ í•´ë‹¹ ë©”ëª¨ë¦¬ ì£¼ì†Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ”ì§€ ê³„ì† ê°ì‹œí•˜ë‹¤ê°€,  ë‹¤ë¥¸ ì‘ì—…ì˜ ë©”ëª¨ë¦¬ ì˜ì—­ìœ¼ë¡œ ë²—ì–´ë‚˜ë©´ interruptë¥¼ ë°œìƒì‹œí‚¤ëŠ” ê²ƒì€?

segmentation ê¸°ë²•

## ë¶€íŒ… ê³¼ì •ì„ ì„¤ëª…í•´ë´

ì»´í“¨í„°ë¥¼ ì¼œë©´ BIOSê°€ ì»´í“¨í„°ì˜ í•˜ë“œì›¨ì–´ë¥¼ ì´ˆê¸°í™”í•˜ê³ , ìì²´ ì ê²€ í›„
ë¶€íŠ¸ ë¡œë”(Boot Loader)ê°€ ìš´ì˜ì²´ì œë¥¼ í•˜ë“œ ë””ìŠ¤í¬ì—ì„œ ì°¾ì•„ì„œ ë©”ëª¨ë¦¬ì— ë¡œë“œí•˜ê³ , ì‹¤í–‰í•œë‹¤. (=boot strap)

## boot loaderê°€ ì¼ í•˜ëŠ” ê²ƒì„ ë­ë¼ê³  í•˜ë‚˜?

ë¶€íŠ¸ ìŠ¤íŠ¸ë©

## pollingì´ ë­ì•¼?

CPUê°€ ì£¼ê¸°ì ìœ¼ë¡œ ì§ì ‘ ì…ì¶œë ¥ì„ ê°€ì§€ëŸ¬ê°€/ë‚´ë³´ë‚´ #í—¬ìŠ¤ì²´í¬

## pollint rateê°€ ë†’ì„ìˆ˜ë¡ ì´ë²¤íŠ¸ ê°ì§€ê°€ ëŠë¦¬ë‹¤.

ì—¿. ì…ë ¥ ì¥ì¹˜ì—ì„œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ì»´í“¨í„°ê°€ í™•ì¸í•˜ëŠ” ë¹ˆë„ê°€ polling rateë‹¤. 

## pollingì˜ ë‹¤ë¥¸ ë§ì€?

programmed io

## ì¸í„°ëŸ½íŠ¸ê°€ ë­ì•¼?

ì™¸ë¶€ì¥ì¹˜ì—ì„œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•´ì„œ cpuë¡œ **IRQ(interrupt request)**ë¥¼ ë³´ë‚´ë©´
CPUëŠ” í˜„ì¬ ê°ì¢… ë ˆì§€ìŠ¤í„°ì™€ ìƒíƒœë¥¼ ì €ì¥í•œ ë’¤,
í•´ë‹¹ Interruptë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë©”ëª¨ë¦¬ ì–´ë”˜ê°€ì— ìˆëŠ” Interrupt Vector Tableì—ì„œ ì‹¤í–‰í•  ISRì˜ ì£¼ì†Œë¥¼ ì°¾ì•„
 **Interrupt Service Routine(ISR)**ìœ¼ë¡œ ì´ë™í•´ ì—´ì¼í•œ í›„,
ì´ì „ì— ìˆ˜í–‰ë˜ë˜ í”„ë¡œì„¸ìŠ¤ë‚˜ ì‘ì—…ìœ¼ë¡œ ëŒì•„ì˜¨ë‹¤.

## interruptì˜ ë‹¤ë¥¸ ë§ì€?

interrupt driven io

## ìµì…‰ì…˜ì€ ì¸í„°ëŸ½íŠ¸ê°€ ì•„ë‹ˆë‹¤.

ì—¿. ì†Œí”„íŠ¸ì›¨ì–´ ì¸í„°ëŸ½íŠ¸ë‹¤.

## DMAê°€ ë­ì•¼?

CPUì˜ ê°œì… ì—†ì´ ë©”ëª¨ë¦¬ì™€ í•˜ë“œì›¨ì–´ ì¥ì¹˜ê°„ ë°ì´í„° ì „ì†¡í•˜ëŠ” ê¸°ìˆ . ì‘ì—… ëë‚˜ë©´ interruptë¡œ ì•Œë¦¼.

## CPUê°€ DMAì—ê²Œ ë²„ìŠ¤ ì‚¬ìš©ì„ ì–‘ë³´í•˜ëŠ” ëª¨ë“œëŠ” burstì´ë‹¤.

ì—¿. cycle modeë‹¤. burst modeëŠ” dmaê°€ ë²„ìŠ¤ ì‚¬ìš©ê¶Œì„ íšë“í•˜ë©´ ì¼ ë‹¤ í•  ë•Œ ê¹Œì§€ busë¥¼ ë…ì í•œë‹¤.

## dmaê°€ cpuì—ê²Œ ìš”êµ¬í•œ ì¹´ìš´íŠ¸ ë§Œí¼ bus ì œì–´ê¶Œì„ ê°€ì§€ëŠ” ëª¨ë“œëŠ”?

demand transfer mode

## DMAëŠ” ë­ì˜ ì•½ìì•¼?

direct memory access

## ë™ì‹œì„±ê³¼ ë³‘ë ¬ì„± ì°¨ì´ê°€ ë­ì•¼?

ë™ì‹œì„±ì€ í•˜ë‚˜ì˜ í”„ë¡œì„¸ì„œì—ì„œ ì—¬ëŸ¬ ì‘ì—…ì„ ë²ˆê°ˆì•„ ê°€ë©° ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ê³ , 
ë³‘ë ¬ì„±ì€ ì—¬ëŸ¬ ê°œì˜ í”„ë¡œì„¸ì„œì—ì„œ ê°ê°ì˜ ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰í•˜ì—¬ ì²˜ë¦¬

## íŒŒì´í”„ë¼ì´ë‹ì´ ë­ì•¼?

 ì²˜ë¦¬í•  ëª…ë ¹ì–´ë¥¼ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ë‚˜ëˆ„ì–´
ê° ë‹¨ê³„ë³„ë¡œ ì „ìš© í•˜ë“œì›¨ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³‘ë ¬ì ìœ¼ë¡œ ì‹¤í–‰í•˜ëŠ” ë°©ì‹

## ì‹œê°„ ì¡ì•„ë¨¹ëŠ” ì‘ì—… ë•Œë¬¸ì—  ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì‹¤í–‰í•  ëª…ë ¹ì–´ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ëŒ€ê¸°í•´ì•¼ í•˜ëŠ” í˜„ìƒì„ ë­ë¼ê³  í•˜ì§€?

pipeline bulbble

## ì‘ì—…ì„ ê²ë‚˜ ë§ì´ ë‚˜ëˆ„ë©´, ê° ë‹¨ê³„ë§ˆë‹¤ ì‘ì—… ì´ë™í•˜ë´, ìƒˆ ì‘ì—… ë¶ˆëŸ¬ì˜¤ë´ ì‹œê°„ ì¡ì•„ë¨¹ì–´ì„œ ì˜¤íˆë ¤ ì„±ëŠ¥ì´ ë–¨ì–´ì§„ë‹¤.

ë§ìŒ.

## structural hazard?

ë‹¤ìˆ˜ì˜ ëª…ë ¹ì´ í•˜ë‚˜ì˜ ìì›ì„ ìŸíƒˆí•˜ë ¤ í•˜ëŠ” ìƒí™©. â†’ ìì› ëŠ˜ë¦¬ê±°ë‚˜, ëŒ€ê¸°í•œë‹¤.

## data hazard?

ì´ì „ ëª…ë ¹ì˜ ê²°ê³¼ë¥¼ ë‹¤ìŒ ëª…ë ¹ì˜ ì…ë ¥ìœ¼ë¡œ ì“°ë ¤ëŠ” ìƒí™©

## control hazard?

í”„ë¡œê·¸ë¨ ì œì–´ ìˆœì„œê°€ ë°”ë€Œì–´ë²„ë ¤ì„œ íŒŒì´í”„ë¼ì¸ì— ëŒì•„ê°€ê³  ìˆëŠ” ëª…ë ¹ì–´ë“¤ì´ ë¬´ì“¸ëª¨ ëœ ìƒí™© â†’ ì˜ˆì¸¡í•˜ê±°ë‚˜ ìš°ì„  ì‹¤í–‰í•œë‹¤.

## í•˜ë‚˜ì˜ ëª…ë ¹ì–´ë¡œ ì—¬ëŸ¬ê°œì˜ ë°ì´í„°ë¥¼ í•œë²ˆì— ì²˜ë¦¬í•˜ëŠ” ê¸°ë²•?

single instruction multiple data (simd)

 # Process: í”„ë¡œì„¸ìŠ¤ life cycle, PCB, memory layout, fork and exec

## í”„ë¡œì„¸ìŠ¤ê°€ ë­ì•¼?

í”„ë¡œê·¸ë¨ì´ ë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°„ê±°.

## í”„ë¡œì„¸ìŠ¤ì˜ life cycleì„ ì„¤ëª…í•´ë´

new : pcb, ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹ë°›ì€ ìƒíƒœ

 â†’ ready : ìŠ¤ì¼€ì¥´ëŸ¬ê°€ dispatchí•˜ê¸° ì „ê¹Œì§€ ì¤€ë¹„ Queueì—ì„œ ì–Œì „íˆ ëŒ€ê¸°

â†’ running : ê°„íƒë°›ì€ í”„ë¡œì„¸ìŠ¤ê°€ íƒ€ì„ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì–»ì–´ cpuì‚¬ìš©ì¤‘. í”„ë¡œì„¸ìŠ¤ ì‚¬ì´ì— context switching ìˆìŒ.  
		(timeout) â†’ ready
		(exit) â†’ terminated
		(io) â†’ blocked

â†’ (blocked)  : ì˜ ëŒë‹¤ê°€ ê¸°ë‹¤ë ¤ì•¼ í•  ìì›ì´ ìˆìœ¼ë©´ ëŒ€ê¸° íì—ì„œ ì–Œì „íˆ ëŒ€ê¸°. ìì› í•´ê²°ë˜ë©´ ë‹¤ì‹œ readyë¡œ ë¹ ê¾¸

â†’ terminated : pcb, ë©”ëª¨ë¦¬ ì œê±°.

## PCBê°€ ë­ì•¼?

OSê°€ í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ë ¤ê³ ,  ë©”ëª¨ë¦¬ì˜ ìš´ì˜ì²´ì œ ì˜ì—­ì— ê¿ì³ë†“ì€,  í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì •ë³´.
í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œì‹œ ì‚¬ë¼ì§.

## í”„ë¡œì„¸ìŠ¤ë“¤ì—ê²Œ ë²ˆê°ˆì•„ê°€ë©° CPUë¥¼ ì‚¬ìš©í•˜ê²Œ í•˜ëŠ” ë°©ë²•?

time slicing 

## context switchingì´ ë­ì•¼?

processë¥¼ ë²ˆê°ˆì•„ ì‹¤í–‰í•˜ëŠ” ë°©ë²•

ì‹¤í–‰ ìƒíƒœì—ì„œ ë‚˜ê°€ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ PCBì—ëŠ” ì§€ê¸ˆê¹Œì§€ì˜ ì‘ì—… ë‚´ìš©ì„ ì €ì¥, â€¨ ë°˜ëŒ€ë¡œ ì‹¤í–‰ ìƒíƒœë¡œ ë“¤ì–´ì˜¤ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ PCBì˜ ë‚´ìš©ìœ¼ë¡œ CPUê°€ ë‹¤ì‹œ ì„¸íŒ…

## CPU ì£¼ì†Œ ê³µê°„ë³´ë‹¤ í° ë©”ëª¨ë¦¬ëŠ” ìˆì–´ë„ ì ‘ê·¼ ëª»í•œë‹¤.

ë§ìŒ.

## í”„ë¡œì„¸ìŠ¤ ì£¼ì†Œ ê³µê°„

í”„ë¡œì„¸ìŠ¤ëŠ” ë§ˆì¹˜ ë©”ëª¨ë¦¬ë¥¼ í˜¼ì ë…ì í•˜ëŠ” ê²ƒ ì²˜ëŸ¼ ë³´ì¸ë‹¤.

## í”„ë¡œì„¸ìŠ¤ ì£¼ì†Œ ê³µê°„ì˜ ì»¤ë„ ê³µê°„ì€ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

ë§ìŒ.

## í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ êµ¬ì¡°

* code - ê°™ì€ í”„ë¡œê·¸ë¨ì´ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ë¡œ ì‹¤í–‰ë˜ë©´ ì—¬ê¸° ê³µìœ 
* data- global, static
* heap
* stack- local, í•¨ìˆ˜ ì¢…ë£Œ í›„ ëŒì•„ê°ˆ ì£¼ì†Œ

## PCBê°€ ì—†ì–´ë„ CPUë¥¼ í• ë‹¹ë°›ì•„ ì‹¤í–‰ì´ ê°€ëŠ¥í•˜ë‹¤.

ì—¿. OSì ì œì–´ ëª»í•˜ë©´ CPU ì–´ë¦¼ë„ ì—†ì§€.

## í”„ë¡œì„¸ìŠ¤ ìƒì„± í›„ ë³µì‚¬?

fork() â†’ exec()

## í”„ë¡œì„¸ìŠ¤ë¥¼ ë³µì‚¬í•˜ëŠ” í•¨ìˆ˜?

ìì‹PID||ì—†ìœ¼ë©´0 fork(); ë©”ëª¨ë¦¬ì™€ ì–´ë””ê¹Œì§€ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€ ê¸ì–´ê°€ ì‚´ë¦¼ ì°¨ë¦¼.ì‹¬ì§€ì–´ ìì›ë„ ê³µìœ  ê°€ëŠ¥.

## ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ì‹¹ ìƒˆë¡œ ì—ëŠ” í•¨ìˆ˜?

exec(); ì‹¬ì§€ì–´ ì½”ë“œ, ë°ì´í„° ì˜ì—­ë„ ì—ìŒ.

## exec()í•˜ë©´ pidê°€ ë³€ê²½ë¨

ì—¿. í”„ë¡œì„¸ìŠ¤ ìƒˆë¡œ ìƒì„±í•˜ëŠ”ê±° ì•„ë‹˜.

## ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ëë‚˜ê¸°ë¥¼ ê¸°ë‹¤ë ¸ë‹¤ê°€ ê·¸ê²Œ ì¢…ë£Œë˜ë©´ ì´ì–´ì„œ ì‹¤í–‰ ê³„ì†í•˜ëŠ” í•¨ìˆ˜

wait(); ìì‹ì˜ ì¢…ë£Œ ì½”ë“œë¥¼ ì½ëŠ” í•¨ìˆ˜ì„. ì´ê²Œ ì‹¤í–‰ì´ ëë‚˜ì•¼ ìì‹ pcbê°€ ì œê±°ë¨. ì—¬ê¸°ì„œ ì‚‘ì‚¬ë¦¬ ë‚˜ë©´ ìì‹ì€ ì¢€ë¹„ê°€ ë˜ë²„ë¦¼.

## exit()ê°€ ë­ì•¼?

ë¶€ëª¨ì—ê²Œ ë³¸ì¸ì˜ ì„ì¢…ê³¼ ì„ì¢… ì‚¬ìœ ë¥¼ ì „ë‹¬í•˜ëŠ” í•¨ìˆ˜. ë©”ëª¨ë¦¬ë„ ë°˜í™˜í•¨.ìì‹ í”„ë¡œì„¸ìŠ¤ë“¤ì„ init í”„ë¡œì„¸ìŠ¤ì—ê²Œ ì…ì–‘.

## ë¶€ëª¨ê°€ ì‹ í˜¸ë¥¼ ë³´ë‚´ì„œ ìì‹ì„ ì£½ì´ëŠ” í•¨ìˆ˜

abort(); 

## ë¶€ëª¨ê°€ ìì‹ì˜ ì¢…ë£Œë¥¼ í™•ì¸í•˜ì§€ ì•Šì•„ ,ì‘ì—… ì¢…ë£Œ í›„ pcbê°€ ë‚¨ì€ ìƒíƒœë¥¼ ê³ ì•„ í”„ë¡œì„¸ìŠ¤ë¼ê³  í•œë‹¤.

ì—¿. ì¢€ë¹„ í”„ë¡œì„¸ìŠ¤ë¼ê³  í•œë‹¤. **ê³ ì•„ í”„ë¡œì„¸ìŠ¤**ëŠ” ë¶€ëª¨ê°€ ë¨¼ì € ì£½ì–´ë²„ë ¤ initì´ ì…ì–‘í•œ í”„ë¡œì„¸ìŠ¤... init(1)ì´ ëŒ€ì‹  wait()í•´ì¤Œ.

## **ìš´ì˜ì²´ì œì˜ ìŠ¤ì¼€ì¤„ë§ ìš°ì„ ìˆœìœ„****: I/O** **ì§‘ì¤‘ í”„ë¡œì„¸ìŠ¤** **> CPU** **ì§‘ì¤‘ í”„ë¡œì„¸ìŠ¤**

ë§ìŒ.



 # Thread: Thread ë©”ëª¨ë¦¬ êµ¬ì¡°, Context switching, Multi-threading model

## threadì–´ë–»ê²Œ ë§Œë“œëŠ”ë°?

í•¨ìˆ˜ë¥¼ ì“°ë ˆë“œë¡œ ë°”ê¿”ë‹¬ë¼ê³  í•˜ë©´ ë˜! ê·¸ëŸ¼ ìŠ¤íƒë§Œ ë”°ë¡œ ì‚´ë¦¼ ì°¨ë ¤ì¤€ë‹¤. pthread_create(pthrad_t &tid, NULL, void *í•¨ìˆ˜ ì´ë¦„, &ë§¤ê°œë³€ìˆ˜)

ë‹¤ ì¼ìœ¼ë©´ ìˆ˜ê±°í•´ì•¼ì§€? pthread_join(pthread_t tid. void **ret)

## threadì˜ ë©”ëª¨ë¦¬ êµ¬ì¡°ëŠ” ì–´ë–»ê²Œ ìƒê²¼ì–´?



## multi threading modelì´ ë­ì•¼?





 # Scheduling: ê°ì¢… ìŠ¤ì¼€ì¥´ë§ ì•Œê³ ë¦¬ì¦˜, time slice



## time sliceì— ëŒ€í•´ ì„¤ëª…í•´ë´



