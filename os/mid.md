 

# 기본적인 OS개념과 형태

## OS가 뭐야?

컴퓨터 시스템에서,
하드웨어 자원을 독점 관리하고, 
하드웨어를 추상화 → 프로그램에게 인터페이스로 제공하는 
시스템 소프트웨어.

## 컴퓨터를 잘 쓰기 위한 OS의 역할 4가지?

* 자원 관리
* 자원 보호
* hw를 위한 인터페이스 제공
* 사용자를 위한 인터페이스 제공

## OS 단점은 없는거야?

성능 느리고, 무지성으로 연결당하는것보단 아예 막아놓는게 안전할지도

## 하나의 CPU로 어떻게 여러 sw를 실행할 수 있어?

그런 기술을 multi-tasking이라 부르는데,  CPU가 짧은 시간 동안 여러 프로세스를 번갈아 가며 처리할 수 있게 운영체제가 관리해줘.

## 프로세스가 언제 작동되어야 하는지 어떻게 결정해?

그걸 결정하는게  스케쥴링 알고리즘이야.

Round Robin, FCFS, SJF 등이 있지.

## 프로세스를 바꾸려면 뭘 준비해야하지?

실행하던 프로세스를 중단하고 (=현재 실행하던 프로세스의 상태를 일단 저장하고)

새로운 프로세스를 메모리에 올려야겠지.  (= 새로운 프로세스의 상태를 복원)

→ 컨텍스트 스위칭을 해야해

## 프로세스의 상태에는 어떤게 있어?



## 중단된 프로세스의 상태는 어디에 저장되는거야?

하드디스크의 일부를 메모리로 사용해서 (= 가상 메모리)

중단된 프로세스를 거기에 저장해 놨다가

필요하면 메모리로 불러와.

## 프로세스가 메모리에 계속 들락날락 해야하는데 어떻게 해?



## CPU랑 메모리는 어떻게 연결하지?

데이터를 전송하는 통로인, 버스를 통해 연결되.

## 내려간 프로세스는 어디에 두지?

그 프로세스의 메모리를 해제하고 할당되어 있던 자원을 반납해야돼.



## OS는 어떻게 생겼어?

* 프로세스, 메모리, 저장장치 관리 기능을 모아둔 **Kernel**
* kernel에 명령을 전달하고 실행 결과를 알려주는 **interface**
* hardware을 추상화시켜놓은 **device driver**

## kernel이 자신의 기능을 함수 형태로 제공해주는 것을 interface라고 한다.

엿. system call이라고 한다. 인터페이스 중 하나가  system call이다.

## 프로세스가 실행되는 두가지 모드가 뭐야?

usermode, kernel mode

## user mode에서는 사용자 프로그램이 실행되며, 시스템 자원에 직접 접근할 수 있다.

엿. system call로 시스템 자원에 간접적으로 접근한다. 그 때 kernel mode로 관련된 커널 기능을 수행하는 프로세스들이 돌아간다.

## OS는 어떤 과정으로 진화했어?

1. 고정 프로그래밍 방식
   * 작업을 처리할 때마다 프로그램을 다시 입력하여 실행하는 방식입니다.
2. 내장 프로그래밍 방식
   * 작업을 처리하는 데 필요한 프로그램이 하드웨어(펀치 카드)에 미리 적혀 있으므로,
     작업을 처리할 때마다 프로그램을 다시 입력하여 실행할 필요가 없이
     실행할 로직을  카드 리더기로 읽어 메모리에 담고,  (= 하드웨어와 소프트웨어의 분리)
     CPU가 로직을 처리하는 방식
   * 미리 정의된 일련의 작업을 일괄적으로 처리하니까 → batch processing 시스템의 탄생이로군.
     * 미리 정의된것만 처리하니까 **중간에** 입력값으로 실행 흐름을 못바꿈 (I/O는 할 수 있음)
       → 작업을 교체해서라도 돌려보려고 하니, 펀치 카드 읽는데 한 세월 🥲
3. 대화형 시스템
   * 입력 값에 따라 작업 흐름을 변경할 수 있게 된 시스템!
     * 그렇다면 키보드로 입력하고 모니터로 출력할래! →근데 스무스하지 않네..? 장치 하나에서 작업 여러개 돌릴 순 없을까?
4. 다중 프로그래밍
   * 작업당 CPU 사용 시간을 분할해서 여러 작업이 실행이 동시에 되는것 처럼 보이게 함.
     * I/O 중인 작업은 CPU 안차지 하니까 다른 작업 하면 되겠다! 스무스하게 보이겠군 ㅎㅎ
5. 네트워크 기반 시스템
   * 자원이 장치 밖까지 확장

## 데드라인 시간 내에 처리를 보장하는 OS?

실시간 운영체제

## 컴퓨터 위에서 하드웨어인 컴퓨터를 소프트웨어로 만들어 돌리는 시스템은?

가상화 시스템 (virtualization)

## os api를 소프트웨어로 시뮬레이션 하는 것이 가상머신이다.

엿. 과정까지 재현한 (=에뮬레이션 한) 것이다. 

## virtualization이 가상머신보다 emulation 범위가 더 넓다.

맞음. virtualization은 컴퓨터를 재현한 것이고, 가상머신(JVM...)은 syscall만 재현한 것이다. 

## 가상 머신은 운영체제와 응용 프로그램 사이에서 돌아간다.

맞음.

## 서버를 거치지 않고 사용자와 사용자를 직접 연결하는 시스템은?

P2P(Peer to Peer) system

## OS는 어떤 자원을 관리해?

* 프로세스 - 이 작업 언제 처리하지?
* 메모리 - 이 좁은 메모리에 어떤 작업을 올려야할까?
* 파일 시스템
* 장치
* 보안
* 네트워크

## 하드웨어의 I/O 신호 규칙은 네트워크 device drive가 정한다.

맞음. "그 신호 이 함수로 ㄱㄱ"



## 커널이 프로세스간 통신 기능만 하고, 나머지 기능은 user mode로 올려놓은 놔서 속도가 뒤지게 느린 것을 계층형 커널이라고 한다.

엿. 마이크로 커널이라고 한다. 

## 마이크로 커널은 프로세스가 죽으면 다운된다.

엿. 그래서 마음놓고 디버깅할 수 있음.

 # Computer architecture: 간단한 컴퓨터의 구조와 작동방식, 병렬처리

## 컴퓨터의 구조는 어떻게 생겼어?

* CPU - 명령어를 해석 & 실행하는 장치
* 메모리 - 명령어와 필요한 데이터 저장하는 곳.
* 버스 - 데이터 통로

## 버스는 한번에 여러 메모리 주소에 접근할 수 있다.

엿. 하나의 메모리 주소밖에 접근 못한다.

## 폰 노이만 구조의 단점이 뭐야?

CPU가 프로그램을 실행시키려면 무조건 메인 메모리에 적재되어 있어야 하는 탓에,
메모리에 갑자기 많은 입출력이 발생하면, (= 이후 요청들은 하나뿐인 데이터버스를 사용할 수 있을 때 까지 기다려야 해서, CPU에 비해 메모리의 작업 속도가 느려짐.)
병목현상이 생긴다.

## 장치들의 작동을 동기화해주는 타이밍을 뭐라고 해?

클럭

## rw를 싣는 버스

제어 버스

## 버스의 크기가 2배 늘어나면, word도 2배 늘어난다.

엿. **한번에 전송할 수 있는 데이터의 크기**가 2배가 된다고 해서 CPU가 한번에 처리할 수 있는 데이터의 크기가 늘어나지는 않는다.

## 앞으로 사용할 것으로 예상되는 데이터를 미리 가져와 저장해두는 장소를 버퍼라고 한다.

엿. 캐시다.  속도 차이가 있는 장치 사이에서 완화하는게 버퍼다. 

잘 팔리는건 근처에 둔다 → 캐시

바쁘니까 한 다라이에 → 버퍼

## 메모리의 계층구조는 어떻게 생겼어?

cpu와 메모리 사이에 끼인 캐시에 CPU가 자주 사용하는 데이터나 명령어가 저장된다.

## CPU가 요청한 데이터가 캐시에 없으면(캐시 미스) CPU는 메모리에서 데이터를 가져와 바로 쓴다.

엿.캐시에 저장하고 다시  캐시 히트.

## CPU는 어떻게 구성되어 있어?

* Arithmetic logic unit
* control unit
* register

## CPU 내의 작업은 모두가 register를 거치는건 아니다.

엿.다 거침.

## cpu는 명령어를 어떻게 처리해?

1. Fetch(인출): CPU는 메모리에서 다음 실행할 명령어를 가져옵니다. 이 명령어는 CPU 내부의 명령어 레지스터(Instruction Register)에 저장됩니다.
2. Decode(해석): CPU는 명령어 레지스터에 저장된 명령어를 해석합니다. 이때 명령어의 오퍼레이션(Operation)과  오퍼랜드(Operand-연산에 사용될 데이터의 위치)를 구분하고, 필요한 레지스터나 메모리 주소 등을 결정합니다.
3. Execute(실행): CPU는 명령어에 따라 적절한 계산이나 연산을 수행합니다. 이때 필요한 데이터는 레지스터나 캐시에서 가져오게 됩니다.
4. Store(저장): CPU는 명령어가 실행된 결과를 메모리나 레지스터에 저장합니다.

## 프로그램을 서로 분리된 논리적인 블록으로 나눠서, 작업이 진행되는 동안 해당 메모리 주소 범위를 벗어나는지 계속 감시하다가,  다른 작업의 메모리 영역으로 벗어나면 interrupt를 발생시키는 것은?

segmentation 기법

## 부팅 과정을 설명해봐

컴퓨터를 켜면 BIOS가 컴퓨터의 하드웨어를 초기화하고, 자체 점검 후
부트 로더(Boot Loader)가 운영체제를 하드 디스크에서 찾아서 메모리에 로드하고, 실행한다. (=boot strap)

## boot loader가 일 하는 것을 뭐라고 하나?

부트 스트랩

## polling이 뭐야?

CPU가 주기적으로 직접 입출력을 가지러가/내보내 #헬스체크

## pollint rate가 높을수록 이벤트 감지가 느리다.

엿. 입력 장치에서 이벤트가 발생하는 것을 컴퓨터가 확인하는 빈도가 polling rate다. 

## polling의 다른 말은?

programmed io

## 인터럽트가 뭐야?

외부장치에서 이벤트가 발생해서 cpu로 **IRQ(interrupt request)**를 보내면
CPU는 현재 각종 레지스터와 상태를 저장한 뒤,
해당 Interrupt를 처리하기 위해 메모리 어딘가에 있는 Interrupt Vector Table에서 실행할 ISR의 주소를 찾아
 **Interrupt Service Routine(ISR)**으로 이동해 열일한 후,
이전에 수행되던 프로세스나 작업으로 돌아온다.

## interrupt의 다른 말은?

interrupt driven io

## 익셉션은 인터럽트가 아니다.

엿. 소프트웨어 인터럽트다.

## DMA가 뭐야?

CPU의 개입 없이 메모리와 하드웨어 장치간 데이터 전송하는 기술. 작업 끝나면 interrupt로 알림.

## CPU가 DMA에게 버스 사용을 양보하는 모드는 burst이다.

엿. cycle mode다. burst mode는 dma가 버스 사용권을 획득하면 일 다 할 때 까지 bus를 독점한다.

## dma가 cpu에게 요구한 카운트 만큼 bus 제어권을 가지는 모드는?

demand transfer mode

## DMA는 뭐의 약자야?

direct memory access

## 동시성과 병렬성 차이가 뭐야?

동시성은 하나의 프로세서에서 여러 작업을 번갈아 가며 처리하는 것이고, 
병렬성은 여러 개의 프로세서에서 각각의 작업을 동시에 실행하여 처리

## 파이프라이닝이 뭐야?

 처리할 명령어를 여러 단계로 나누어
각 단계별로 전용 하드웨어를 사용하여 병렬적으로 실행하는 방식

## 시간 잡아먹는 작업 때문에  다음 단계에서 실행할 명령어가 준비되지 않은 상태로 대기해야 하는 현상을 뭐라고 하지?

pipeline bulbble

## 작업을 겁나 많이 나누면, 각 단계마다 작업 이동하랴, 새 작업 불러오랴 시간 잡아먹어서 오히려 성능이 떨어진다.

맞음.

## structural hazard?

다수의 명령이 하나의 자원을 쟁탈하려 하는 상황. → 자원 늘리거나, 대기한다.

## data hazard?

이전 명령의 결과를 다음 명령의 입력으로 쓰려는 상황

## control hazard?

프로그램 제어 순서가 바뀌어버려서 파이프라인에 돌아가고 있는 명령어들이 무쓸모 된 상황 → 예측하거나 우선 실행한다.

## 하나의 명령어로 여러개의 데이터를 한번에 처리하는 기법?

single instruction multiple data (simd)

 # Process: 프로세스 life cycle, PCB, memory layout, fork and exec

## 프로세스가 뭐야?

프로그램이 메모리에 올라간거.

## 프로세스의 life cycle을 설명해봐

new : pcb, 메모리를 할당받은 상태

 → ready : 스케쥴러가 dispatch하기 전까지 준비 Queue에서 얌전히 대기

→ running : 간택받은 프로세스가 타임 슬라이스를 얻어 cpu사용중. 프로세스 사이에 context switching 있음.  
		(timeout) → ready
		(exit) → terminated
		(io) → blocked

→ (blocked)  : 잘 돌다가 기다려야 할 자원이 있으면 대기 큐에서 얌전히 대기. 자원 해결되면 다시 ready로 빠꾸

→ terminated : pcb, 메모리 제거.

## PCB가 뭐야?

OS가 프로세스를 관리하려고,  메모리의 운영체제 영역에 꿍쳐놓은,  프로세스 상태 정보.
프로세스 종료시 사라짐.

## 프로세스들에게 번갈아가며 CPU를 사용하게 하는 방법?

time slicing 

## context switching이 뭐야?

process를 번갈아 실행하는 방법

실행 상태에서 나가는 프로세스의 PCB에는 지금까지의 작업 내용을 저장,   반대로 실행 상태로 들어오는 프로세스의 PCB의 내용으로 CPU가 다시 세팅

## CPU 주소 공간보다 큰 메모리는 있어도 접근 못한다.

맞음.

## 프로세스 주소 공간

프로세스는 마치 메모리를 혼자 독점하는 것 처럼 보인다.

## 프로세스 주소 공간의 커널 공간은 모든 프로세스가 사용할 수 있다.

맞음.

## 프로세스 메모리 구조

* code - 같은 프로그램이 여러 프로세스로 실행되면 여기 공유
* data- global, static
* heap
* stack- local, 함수 종료 후 돌아갈 주소

## PCB가 없어도 CPU를 할당받아 실행이 가능하다.

엿. OS자 제어 못하면 CPU 어림도 없지.

## 프로세스 생성 후 복사?

fork() → exec()

## 프로세스를 복사하는 함수?

자식PID||없으면0 fork(); 메모리와 어디까지 실행되었는지 긁어가 살림 차림.심지어 자원도 공유 가능.

## 기존 프로세스의 메모리 싹 새로 엎는 함수?

exec(); 심지어 코드, 데이터 영역도 엎음.

## exec()하면 pid가 변경됨

엿. 프로세스 새로 생성하는거 아님.

## 자식 프로세스가 끝나기를 기다렸다가 그게 종료되면 이어서 실행 계속하는 함수

wait(); 자식의 종료 코드를 읽는 함수임. 이게 실행이 끝나야 자식 pcb가 제거됨. 여기서 삑사리 나면 자식은 좀비가 되버림.

## exit()가 뭐야?

부모에게 본인의 임종과 임종 사유를 전달하는 함수. 메모리도 반환함.자식 프로세스들을 init 프로세스에게 입양.

## 부모가 신호를 보내서 자식을 죽이는 함수

abort(); 

## 부모가 자식의 종료를 확인하지 않아 ,작업 종료 후 pcb가 남은 상태를 고아 프로세스라고 한다.

엿. 좀비 프로세스라고 한다. **고아 프로세스**는 부모가 먼저 죽어버려 init이 입양한 프로세스... init(1)이 대신 wait()해줌.

## **운영체제의 스케줄링 우선순위****: I/O** **집중 프로세스** **> CPU** **집중 프로세스**

맞음.



 # Thread: Thread 메모리 구조, Context switching, Multi-threading model

## thread어떻게 만드는데?

함수를 쓰레드로 바꿔달라고 하면 되! 그럼 스택만 따로 살림 차려준다. pthread_create(pthrad_t &tid, NULL, void *함수 이름, &매개변수)

다 썼으면 수거해야지? pthread_join(pthread_t tid. void **ret)

## thread의 메모리 구조는 어떻게 생겼어?



## multi threading model이 뭐야?





 # Scheduling: 각종 스케쥴링 알고리즘, time slice



## time slice에 대해 설명해봐



